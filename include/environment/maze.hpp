/*
 *  Copyright 2019 Maxine Michalski <maxine@furfind.net>
 *
 *  This file is part of Alex.
 *
 *  Alex is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Alex is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Alex.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <cstdlib>
#include <ctime>
#include <algorithm>

#include "environment.hpp"

#ifndef MAZE_H
#define iMAZE_H

#define WIDTH	16
#define HEIGHT	10

/** @class Maze
 *
 * @brief Environment for the mazes based games.
 *
 * Mazes are generated by the randomized depth-first search algorithm and will
 * have a reward placed inside of them randomly.
 * 
 * The goal is to find the power cell in a minimal amount of steps.
 *
 * Rules:
 * - legal actions are up, right, down, left
 * - actions, that would cause the player to move into a wall are illegal
 * - the player has a certain amount of energy (200)
 * - each step takes 1 energy
 * - if 0 energy is reached, the game is over
 * - if the power cell is reached
 *   - 20 reward are provided
 *   - 200 energy are recharged (no max cap)
 *   - power drain is increased by 1
 * - a player can dispatch Alex, this causes:
 *   - a flat drain of 10 energy
 *   - Alex to explore the maze and improve her helping role
 *   - this can be done at any time, but may cause a game over state if energy
 *   is >= 10
 *
 * @author Maxine Michalski
 */
class Maze : public Environment {
	public:
		/** @brief initializer method
		 *
		 * This method setups a randomly generated maze, using a randomized
		 * depth-first search algorithm.
		 *
		 * Some other setup are done too, like placing a power cell.
		 */
		Maze();
		/** @see Environment::act() */
		bool act(unsigned short action);
		/** @see Environment::width() */
		unsigned int width() { return _width; };
		/** @see Environment::height() */
		unsigned int height() { return _height; };
		/** @see Environment::valid_actions() */
		unsigned short valid_actions();
		/** @see Environment::state() */
		std::vector<unsigned int> state();
		char *map() { return &nodes[0][0]; }
	private:
		/** @brief Randomized depth-first search algorithm */
		void process_node(int x, int y);
		int x = 0, y = 0;
		int _width = WIDTH, _height = HEIGHT;
		char nodes[WIDTH][HEIGHT];
		int energy = 200, drain = 1;
};

#undef WIDTH
#undef HEIGHT

#endif // MAZE_H
